#### 1、为什么使用泛型设计

##### 1.1 没有泛型的代码

```java
public class ArrayList {
    private Object[] elementData;
    ...
    public Object get(int i) {... }
    public void add(Object o) { ... }
}
```



#### 2、泛型类

一个泛型类（generic class）就是具有一个或多个类型变量的类

```java
// 一个类型变量(T)
public class Pair<T> {
    private T first;
    private T second;
    
    // 无参构造
    public Pair() {
        this.first = null;
        this.second = null;
    }
    // 有参构造
    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }
    
    public void setFirst(T first) { this.first = first; }
    
    public T getFirst() { return first; }
    
    public void setSecond(T second) { this.second = second; }
    
    public T getSecond() { return second; }
}
```

```java
// 多个类型变量类(T,U)
public class Pair<T,U> {...}
```

类中定义的类型变量，可以指定**方法的返回类型**、**域**、**局部变量的类型**。

```java
private T first;
```

例子：

```java
public class PairTest1 {
    public static void main(String[] args) {
        String[] words = {"Mary", "had", "a", "little", "lamb"};
        Pair<String> mm = ArrayAlg.minmax(words);
        System.out.println("min = " + mm.getFirst());
        System.out.println("max = " + mm.getSecond());
    }
}
class ArrayAlg {
    public static Pair<String> minmax(String[] a) {
        if (a == null || a.length == 0) return null;
        String min = a[0];
        String max = a[0];
        for (int i = 1; i < a.length; i++) {
            System.out.println("a[i]:"+a[i]);
            if (min.compareTo(a[i]) > 0) min = a[i];
            if (max.compareTo(a[i]) < 0) max = a[i];
        }
        return new Pair<>(min, max);
    }
}
// 理解String的compareTo方法
```

#### 3、泛型方法

泛型方法可以定义在普通类中，也可以定义在泛型类中。
在泛型类中，泛型方法通常用于需要不同类型的参数而**不依赖于类的泛型类型**。

```java
public class ArrayAlg {
    // T（类型变量）放在修饰符（这里是public static）的后面，返回类型的前面。
    public static <T> T getMiddle(T... a){
        return a[a.length/2];
    }
}
```

深入：

```java
// 不兼容的类型：
// Incompatible types: Number & Comparable<? extends Number & Comparable<?> & Constable & ConstantDesc> & Constable & ConstantDesc is not convertible to double
double middle = ArrayAlg2.getMiddle(3.14, 1729, 0); 

```

1、错误消息会以晦涩的方式指出：解释这句代码有两种方法，而且这两种方法都是合法的。
2、编译器将自动打包参数为1个Double和2个Integer对象，而后寻找这些类的`共同超类型`。
3、事实上，找到2个这样的超类型：Number和Comparable接口，其本身也是一个泛型类型。在这种情况下，可以将所有的参数写为double值。

#### 4、类型变量的限定

##### 4.1 背景

未使用类型变量限定产生的问题：

```java
public class ArrayAlg3 {
    public static <T> T min(T[] a) {
        if (a == null || a.length == 0) return null;
        T smallest = a[0];
        for (int i = 1; i < a.length; i++) {
            // Cannot resolve method 'compareTo' in 'T'
            if (smallest.compareTo(a[i]) > 0) smallest = a[i];
        }
        return smallest;
    }
}
```

出现上述问题，因为编译器不知道T所属的类，有无compareTo方法

```java
// 使用类型变量的限定
public static <T extends Comparable> T min(T[] a) ...
```

##### 4.2 使用

使用泛型变量的限定时，extends关键字后面可以跟类和接口，这样做的原因是extends更接近子类的概念。
一个类型变量或通配符可以有多个限定，限定类型用`&`分隔，逗号用来分隔类型变量

```java
T extends Comparable & Serializable
```

例子：

```java
// 重载上面ArrayAlg的minmax方法
public static <T extends Comparable> Pair<T> minmax(T[] a) {
    if (a == null || a.length == 0) return null;
    T min = a[0];
    T max = a[0];
    for (int i = 1; i < a.length; i++) {
        if (min.compareTo(a[i]) > 0) min = a[i];
        if (max.compareTo(a[i]) < 0) max = a[i];
    }
    return new Pair<>(min, max);
}
```

#### 5、泛型代码和虚拟机

虚拟机没有泛型类型对象——所有对象都属于普通类。

##### 5.1 类型擦除

每一个泛型，都会有相应的原始类型（raw type）。原始类型的名字就是删除类型参数后的泛型类型名。
擦除（erased）类型变量，并替换为限定类型（无限定的变量用Object）。

###### 5.1.1 erased类无限定类型

没有用限定，原始类型用Object替换T

```java
// erased之后
public class Pair<Object> {
    private Object first;
    private Object second;
    
    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }
    
    public void setFirst(Object first) { this.first = first; }
    
    public Object getFirst() { return first; }
    
    public void setSecond(Object second) { this.second = second; }
    
    public Object getSecond() { return second; }
}
```

###### 5.1.2 erased类多个限定类型

用了限定类型，原始类型用限定类型替换T

```java
// erased之前
public class Interval<T extends Comparable & Serializable> implements Serializable {
    private T lower;
    private T upper;
    ...
    public Interval(T first, T second) {
        if(first.compareTo(second) <= 0)} {
        	lower = first; 
        	upper = second;
    	} else {
        	lower = second;
        	upper = first;
    	}
    }    
}
// erased之后
public class Interval implements Serializable {
    private Comparable lower;
    private Comparable upper;
    ...
    public Interval(Comparable first, Comparable second) {
        if(first.compareTo(second) <= 0)} {
        	lower = first; 
        	upper = second;
    	} else {
        	lower = second;
        	upper = first;
    	}
    }    
}
```

上述例子中，使用了多个限定类型变量在erased时，原始类型用第一个限定的类型变量（Comparable）来替换。

关于切换限定：假设`class Interval<T extends Serializable & Comparable>`是这样的。原始类型用Serializable替换T，而编译器在必要时要向Comparable插入强制类型转换。为了提高效率，**应该将标签（tagging）接口（即没有方法的接口）放在边界列表的末尾**。

##### 5.2 翻译泛型表达式

###### 5.2.1 类中的表达式

当程序调用泛型类中**带有类类型变量的方法**（非泛型方法）时，如果擦除返回类型，编译器插入强制类型转换。
例如：

```java
// 构造
Pair<Employee> buddies = ... ;
// 调用
Employee buddy = buddies.getFirst();
```

擦除getFirst的返回类型后将返回Object类型。编译器自动插入Employee的强制类型转换。也就是说，编译器把这个方法调用翻译为两条虚拟机指令：

- 对原始方法Pair.getFirst的调用
- 将返回的Object类型强制转换为Employee类型

###### 5.2.2 类中的属性

当存取一个泛型域时也要插入强制类型转换。假设Pair类的first域和second域都是公有的（也许这不是一种好的编程风格，但在Java中是合法的）。表达式：

```java
Employee buddy = buddies.first;
```

会在结果字节码中插入强制类型转换

##### 5.3 翻译泛型方法

###### 5.3.1 erased泛型方法

例如：
一个完整的泛型方法

```java
public static <T extends Comparable> T min(T[] a)
```

擦除后（erased），只剩下限定类型Comparable

```java
public static Comparable min(Comparable[] a)
```

###### 5.3.2 erased后产生的多态冲突

产生的冲突：
子类重写父类的方法后，由于多态的特性一定会调用子类中重写的父类方法，但是在擦除类型变量后，子类重写的方法与父类是两个不一样的方法，导致多态失效

```java
class Employee<T> {
    private T name;
    
    public T getName() { return name; }
    
    public void setName(T name) { this.name = name; }
}

class Manager extends Employee<String>{
    private Integer id;
    
    public Integer getId() { return id; }
    
    public void setId(Integer id) { this.id = id; }
    
    public void setName(String name) {
        super.setName(name);
    }
}
```

调用

```java
Manager manager = new Manager(...);
Employee<String> employee = manager;
employee.setName("Tom");
```

```
employee.setName("Tom");
调用细节：
employee是Employee对象的引用，会去Employee中寻找setName(Object name)方法，
employee指向的对象是Manager，会用Manager.setName(Object name)，
但是Manager中只有Employee.setName(Object name)，因此会在Manager中生成桥方法
```

方法表

```java
Employee:
	getName() -> Employee.getName()
    // 泛型方法被擦除之后    
	setName(Object name) -> Employee.setName(Object name)
        
Manager:
	getId() -> Manager.getId()
    setId(Integer id) -> Manager.setId(Integer id)
    // setName(String name) -> Manager.setName(String name)
    // 继承过来的方法
	// setName(Object name) -> Employee.setName(Object name)
	getName() -> Employee.getName()
    // 生成的桥方法，解决因擦除导致多态冲突    
    setName(Object name) -> Manager.setName(Object name){
        					 setName(String name)
    					  }
	
```



##### 5.4 调用遗留代码



#### 6、约束与局限性



#### 7、泛型类型的继承规则

#### 8、通配符类型

#### 9、反射和泛型

