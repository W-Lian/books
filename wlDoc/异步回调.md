##### 1、jdk

###### 1.1 join

```java
import java.util.*;

public class WebsiteStatsCollector {

    // 模拟结果容器（线程安全）
    private static final Map<String, Integer> resultMap = Collections.synchronizedMap(new HashMap<>());

    public static void main(String[] args) throws InterruptedException {
        // 要抓取的网站列表
        List<String> websites = Arrays.asList("siteA.com", "siteB.com", "siteC.com");

        // 存放线程对象
        List<Thread> threads = new ArrayList<>();

        // 为每个网站启动一个线程
        for (String site : websites) {
            Thread thread = new Thread(() -> {
                int visitCount = fetchVisitCount(site);
                resultMap.put(site, visitCount);
                System.out.println(site + " 数据收集完成，访问量：" + visitCount);
            });

            thread.start();
            threads.add(thread);
        }

        // 主线程等待所有子线程完成
        for (Thread t : threads) {
            t.join();  // 阻塞等待
        }

        // 所有子线程完成，进行结果汇总
        System.out.println("\n📊 所有网站访问量统计：");
        resultMap.forEach((site, count) -> System.out.println(site + ": " + count));
    }

    // 模拟抓取方法（随机生成访问量 + 睡眠模拟延迟）
    private static int fetchVisitCount(String site) {
        try {
            Thread.sleep((int)(Math.random() * 3000)); // 模拟网络延迟
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return new Random().nextInt(10000); // 模拟访问量
    }
}

```





###### 1.2 Future接口、FutureTask类

```java
package com.crazymakercircle.coccurent;
//...
public class JavaFutureDemo {
    public static final int SLEEP_GAP = 500;
    public static String getCurThreadName() {
        return Thread.currentThread().getName();
    } 
    static class HotWarterJob implements Callable<Boolean> //①
    {
        @Override
        public Boolean call() throws Exception //②
        {
            try {
                Logger.info（"洗好水壶"）;
                Logger.info（"灌上凉水"）;
                Logger.info（"放在火上"）;
                //线程睡眠一段时间，代表烧水中
                Thread.sleep(SLEEP_GAP);
                Logger.info（"水开了"）;
            } catch (InterruptedException e) {
                Logger.info（" 发生异常被中断."）;
                return false;
            }
            Logger.info（" 运行结束."）;
            return true;
        }
    }
    static class WashJob implements Callable<Boolean> {
        @Override
        public Boolean call() throws Exception {
            try {
                Logger.info（"洗茶壶"）;
                Logger.info（"洗茶杯"）;
                Logger.info（"拿茶叶"）;
                //线程睡眠一段时间，代表清洗中
                Thread.sleep(SLEEP_GAP);
                Logger.info（"洗完了"）;
            } catch (InterruptedException e) {
                Logger.info（" 清洗工作发生异常被中断."）;
                return false;
            }
            Logger.info（" 清洗工作运行结束."）;
            return true;
        }
    }
    public static void drinkTea(booleanwarterOk, booleancupOk) {
        if (warterOk&&cupOk) {
            Logger.info（"泡茶喝"）;
        } else if (!warterOk) {
            Logger.info（"烧水失败，没有茶喝了"）;
        } else if (!cupOk) {
            Logger.info（"杯子洗不了，没有茶喝了"）;
        }
    }
    public static void main(String args[]) {
        Callable<Boolean>hJob = new HotWarterJob();//③
        FutureTask<Boolean>hTask = new FutureTask<>(hJob);//④
        Thread hThread = new Thread（hTask, "** 烧水-Thread"）;//⑤
        Callable<Boolean>wJob = new WashJob();//③
        FutureTask<Boolean>wTask = new FutureTask<>(wJob);//④
        Thread wThread = new Thread（wTask, "$$ 清洗-Thread"）;//⑤
        hThread.start();
        wThread.start();
        Thread.currentThread().setName（"主线程"）;
            try {
                booleanwarterOk = hTask.get();
                booleancupOk = wTask.get();
                drinkTea(warterOk, cupOk);
            } catch (InterruptedException e) {
                Logger.info(getCurThreadName() + "发生异常被中断.");
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        Logger.info(getCurThreadName() + " 运行结束.");
    }
}
```



##### 2、Guava

FutureCallback、ListenableFuture

```java
package com.crazymakercircle.coccurent;
//….
public class GuavaFutureDemo {
    public static final int SLEEP_GAP = 500;
    public static String getCurThreadName() {
        return Thread.currentThread().getName();
    }
    //业务逻辑：烧水
    static class HotWarterJob implements Callable<Boolean>
    {
        @Override
        public Boolean call() throws Exception 
        {
            //……省略，与使用FutureTask实现异步泡茶喝相同
        }
    }
    //业务逻辑：清洗
    static class WashJob implements Callable<Boolean> {
        @Override
        public Boolean call() throws Exception {
            //……省略，与使用FutureTask实现异步泡茶喝相同
        }
    }
    //新创建一个异步业务类型，作为泡茶喝主线程类
    static class MainJob implements Runnable {
    booleanwarterOk = false;
    booleancupOk = false;
        int gap = SLEEP_GAP / 10;
        @Override
        public void run() {
            while (true) {
                try {
                    Thread.sleep(gap);
                    Logger.info（"读书中......"）;
                } catch (InterruptedException e) {
                    Logger.info(getCurThreadName() + "发生异常被中断.");
                }
                if (warterOk&&cupOk) {
                    drinkTea(warterOk, cupOk);
                }
            }
        }
        public void drinkTea(Boolean wOk, Boolean cOK) {
            if (wOk&&cOK) {
                Logger.info（"泡茶喝，茶喝完"）;
                this.warterOk = false;
                this.gap = SLEEP_GAP * 100;
            } else if (!wOk) {
                Logger.info（"烧水失败，没有茶喝了"）;
            } else if (!cOK) {
                Logger.info（"杯子洗不了，没有茶喝了"）;
            }
        }
    }
    public static void main(String args[]) {
        //创建一个新的线程实例，作为泡茶主线程
        MainJobmainJob = new MainJob();
        Thread mainThread = new Thread(mainJob);
        mainThread.setName（"主线程"）;
        mainThread.start();
        //烧水的业务逻辑实例
        Callable<Boolean>hotJob = new HotWarterJob();
        //清洗的业务逻辑实例
        Callable<Boolean>washJob = new WashJob();
        //创建Java 线程池
        ExecutorServicejPool = Executors.newFixedThreadPool(10);
        //包装Java线程池，构造Guava 线程池
        ListeningExecutorServicegPool 
                         = MoreExecutors.listeningDecorator(jPool);
        //提交烧水的业务逻辑实例，到Guava线程池获取异步任务
        ListenableFuture<Boolean>hotFuture = gPool.submit(hotJob);
        //绑定异步回调，烧水完成后，把喝水任务的warterOk标志设置为true
        Futures.addCallback(hotFuture, new FutureCallback<Boolean>() {
            public void onSuccess(Boolean r) {
                if (r) {
                    mainJob.warterOk = true;
                }
            }
            public void onFailure(Throwable t) {
                Logger.info（"烧水失败，没有茶喝了"）;
            }
        };
        //提交清洗的业务逻辑实例，到Guava线程池获取异步任务
        ListenableFuture<Boolean>washFuture = gPool.submit(washJob);
        //绑定任务执行完成后的回调逻辑到异步任务
        Futures.addCallback(washFuture, new FutureCallback<Boolean>() {
            public void onSuccess(Boolean r) {
                if (r) {
                    mainJob.cupOk = true;
                }
            }
            public void onFailure(Throwable t) {
                Logger.info（"杯子洗不了，没有茶喝了"）;
            }
        });
    }
}
```





























